/*
 Navicat Premium Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80018
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80018
 File Encoding         : 65001

 Date: 18/11/2019 16:03:36
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章内容',
  `title` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章标题',
  `view_count` int(255) unsigned NOT NULL COMMENT '阅读次数',
  `comment_count` int(255) unsigned NOT NULL COMMENT '评论次数',
  `username` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章作者',
  `summary` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章摘要',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
BEGIN;
INSERT INTO `article` VALUES (1, 'Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n\n类型别名和自定义类型\n==========\n\n自定义类型\n-----\n\n在Go语言中有一些基本的数据类型，如`string`、`整型`、`浮点型`、`布尔`等数据类型， Go语言中可以使用`type`关键字来定义自定义类型。\n\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：\n\n    //将MyInt定义为int类型\n    type MyInt int\n    \n\n通过`Type`关键字的定义，`MyInt`就是一种新的类型，它具有`int`的特性。\n\n类型别名\n----\n\n类型别名是`Go1.9`版本添加的新功能。\n\n类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。\n\n    type TypeAlias = Type\n    \n\n我们之前见过的`rune`和`byte`就是类型别名，他们的定义如下：\n\n    type byte = uint8\n    type rune = int32\n    \n\n类型定义和类型别名的区别\n------------\n\n类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。\n\n    //类型定义\n    type NewInt int\n    \n    //类型别名\n    type MyInt = int\n    \n    func main() {\n    	var a NewInt\n    	var b MyInt\n    	\n    	fmt.Printf(\"type of a:%T\\n\", a) //type of a:main.NewInt\n    	fmt.Printf(\"type of b:%T\\n\", b) //type of b:int\n    }\n    \n\n结果显示a的类型是`main.NewInt`，表示main包下定义的`NewInt`类型。b的类型是`int`。`MyInt`类型只会在代码中存在，编译完成时并不会有`MyInt`类型。\n\n结构体\n===\n\nGo语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称`struct`。 也就是我们可以通过`struct`来定义自己的类型了。\n\nGo语言中通过`struct`来实现面向对象。\n\n结构体的定义\n------\n\n使用`type`和`struct`关键字来定义结构体，具体代码格式如下：\n\n    type 类型名 struct {\n        字段名 字段类型\n        字段名 字段类型\n        …\n    }\n    \n\n其中：\n\n*   类型名：标识自定义结构体的名称，在同一个包内不能重复。\n*   字段名：表示结构体字段名。结构体中的字段名必须唯一。\n*   字段类型：表示结构体字段的具体类型。\n\n举个例子，我们定义一个`Person`（人）结构体，代码如下：\n\n    type person struct {\n    	name string\n    	city string\n    	age  int8\n    }\n    \n\n同样类型的字段也可以写在一行，\n\n    type person1 struct {\n    	name, city string\n    	age        int8\n    }\n    \n\n这样我们就拥有了一个`person`的自定义类型，它有`name`、`city`、`age`三个字段，分别表示姓名、城市和年龄。这样我们使用这个`person`结构体就能够很方便的在程序中表示和存储人信息了。\n\n语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型\n\n结构体实例化\n------\n\n只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。\n\n结构体本身也是一种类型，我们可以像声明内置类型一样使用`var`关键字声明结构体类型。\n\n    var 结构体实例 结构体类型\n    \n\n### 基本实例化\n\n举个例子：\n\n    type person struct {\n    	name string\n    	city string\n    	age  int8\n    }\n    \n    func main() {\n    	var p1 person\n    	p1.name = \"沙河娜扎\"\n    	p1.city = \"北京\"\n    	p1.age = 18\n    	fmt.Printf(\"p1=%v\\n\", p1)  //p1={沙河娜扎 北京 18}\n    	fmt.Printf(\"p1=%#v\\n\", p1) //p1=main.person{name:\"沙河娜扎\", city:\"北京\", age:18}\n    }\n    \n\n我们通过`.`来访问结构体的字段（成员变量）,例如`p1.name`和`p1.age`等。\n\n### 匿名结构体\n\n在定义一些临时数据结构等场景下还可以使用匿名结构体。\n\n    package main\n         \n    import (\n        \"fmt\"\n    )\n         \n    func main() {\n        var user struct{Name string; Age int}\n        user.Name = \"小王子\"\n        user.Age = 18\n        fmt.Printf(\"%#v\\n\", user)\n    }\n    \n\n### 创建指针类型结构体\n\n我们还可以通过使用`new`关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：\n\n    var p2 = new(person)\n    fmt.Printf(\"%T\\n\", p2)     //*main.person\n    fmt.Printf(\"p2=%#v\\n\", p2) //p2=&main.person{name:\"\", city:\"\", age:0}\n    \n\n从打印的结果中我们可以看出`p2`是一个结构体指针。\n\n需要注意的是在Go语言中支持对结构体指针直接使用`.`来访问结构体的成员。\n\n    var p2 = new(person)\n    p2.name = \"小王子\"\n    p2.age = 28\n    p2.city = \"上海\"\n    fmt.Printf(\"p2=%#v\\n\", p2) //p2=&main.person{name:\"小王子\", city:\"上海\", age:28}\n    \n\n### 取结构体的地址实例化\n\n使用`&`对结构体进行取地址操作相当于对该结构体类型进行了一次`new`实例化操作。\n\n    p3 := &person{}\n    fmt.Printf(\"%T\\n\", p3)     //*main.person\n    fmt.Printf(\"p3=%#v\\n\", p3) //p3=&main.person{name:\"\", city:\"\", age:0}\n    p3.name = \"七米\"\n    p3.age = 30\n    p3.city = \"成都\"\n    fmt.Printf(\"p3=%#v\\n\", p3) //p3=&main.person{name:\"七米\", city:\"成都\", age:30}\n    \n\n`p3.name = \"七米\"`其实在底层是`(*p3).name = \"七米\"`，这是Go语言帮我们实现的语法糖。\n\n结构体初始化\n------\n\n没有初始化的结构体，其成员变量都是对应其类型的零值。\n\n    type person struct {\n    	name string\n    	city string\n    	age  int8\n    }\n    \n    func main() {\n    	var p4 person\n    	fmt.Printf(\"p4=%#v\\n\", p4) //p4=main.person{name:\"\", city:\"\", age:0}\n    }\n    \n\n### 使用键值对初始化\n\n使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。\n\n    p5 := person{\n    	name: \"小王子\",\n    	city: \"北京\",\n    	age:  18,\n    }\n    fmt.Printf(\"p5=%#v\\n\", p5) //p5=main.person{name:\"小王子\", city:\"北京\", age:18}\n    \n\n也可以对结构体指针进行键值对初始化，例如：\n\n    p6 := &person{\n    	name: \"小王子\",\n    	city: \"北京\",\n    	age:  18,\n    }\n    fmt.Printf(\"p6=%#v\\n\", p6) //p6=&main.person{name:\"小王子\", city:\"北京\", age:18}\n    \n\n当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。\n\n    p7 := &person{\n    	city: \"北京\",\n    }\n    fmt.Printf(\"p7=%#v\\n\", p7) //p7=&main.person{name:\"\", city:\"北京\", age:0}\n    \n\n### 使用值的列表初始化\n\n初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：\n\n    p8 := &person{\n    	\"沙河娜扎\",\n    	\"北京\",\n    	28,\n    }\n    fmt.Printf(\"p8=%#v\\n\", p8) //p8=&main.person{name:\"沙河娜扎\", city:\"北京\", age:28}\n    \n\n使用这种格式初始化时，需要注意：\n\n1.  必须初始化结构体的所有字段。\n2.  初始值的填充顺序必须与字段在结构体中的声明顺序一致。\n3.  该方式不能和键值初始化方式混用。\n\n结构体内存布局\n-------\n\n结构体占用一块连续的内存。\n\n    type test struct {\n    	a int8\n    	b int8\n    	c int8\n    	d int8\n    }\n    n := test{\n    	1, 2, 3, 4,\n    }\n    fmt.Printf(\"n.a %p\\n\", &n.a)\n    fmt.Printf(\"n.b %p\\n\", &n.b)\n    fmt.Printf(\"n.c %p\\n\", &n.c)\n    fmt.Printf(\"n.d %p\\n\", &n.d)\n    \n\n输出：\n\n    n.a 0xc0000a0060\n    n.b 0xc0000a0061\n    n.c 0xc0000a0062\n    n.d 0xc0000a0063\n    \n\n【进阶知识点】关于Go语言中的内存对齐推荐阅读:[在 Go 中恰到好处的内存对齐](https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com)\n\n面试题\n---\n\n请问下面代码的执行结果是什么？\n\n    type student struct {\n    	name string\n    	age  int\n    }\n    \n    func main() {\n    	m := make(map[string]*student)\n    	stus := []student{\n    		{name: \"小王子\", age: 18},\n    		{name: \"娜扎\", age: 23},\n    		{name: \"大王八\", age: 9000},\n    	}\n    \n    	for _, stu := range stus {\n    		m[stu.name] = &stu\n    	}\n    	for k, v := range m {\n    		fmt.Println(k, \"=>\", v.name)\n    	}\n    }\n    \n\n构造函数\n----\n\nGo语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个`person`的构造函数。 因为`struct`是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。\n\n    func newPerson(name, city string, age int8) *person {\n    	return &person{\n    		name: name,\n    		city: city,\n    		age:  age,\n    	}\n    }\n    \n\n调用构造函数\n\n    p9 := newPerson(\"张三\", \"沙河\", 90)\n    fmt.Printf(\"%#v\\n\", p9) //&main.person{name:\"张三\", city:\"沙河\", age:90}\n    \n\n方法和接收者\n------\n\nGo语言中的`方法（Method）`是一种作用于特定类型变量的函数。这种特定类型变量叫做`接收者（Receiver）`。接收者的概念就类似于其他语言中的`this`或者 `self`。\n\n方法的定义格式如下：\n\n    func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {\n        函数体\n    }\n    \n\n其中，\n\n*   接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是`self`、`this`之类的命名。例如，`Person`类型的接收者变量应该命名为 `p`，`Connector`类型的接收者变量应该命名为`c`等。\n*   接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。\n*   方法名、参数列表、返回参数：具体格式与函数定义相同。\n\n举个例子：\n\n    //Person 结构体\n    type Person struct {\n    	name string\n    	age  int8\n    }\n    \n    //NewPerson 构造函数\n    func NewPerson(name string, age int8) *Person {\n    	return &Person{\n    		name: name,\n    		age:  age,\n    	}\n    }\n    \n    //Dream Person做梦的方法\n    func (p Person) Dream() {\n    	fmt.Printf(\"%s的梦想是学好Go语言！\\n\", p.name)\n    }\n    \n    func main() {\n    	p1 := NewPerson(\"小王子\", 25)\n    	p1.Dream()\n    }\n    \n\n方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。\n\n### 指针类型的接收者\n\n指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的`this`或者`self`。 例如我们为`Person`添加一个`SetAge`方法，来修改实例变量的年龄。\n\n    // SetAge 设置p的年龄\n    // 使用指针接收者\n    func (p *Person) SetAge(newAge int8) {\n    	p.age = newAge\n    }\n    \n\n调用该方法：\n\n    func main() {\n    	p1 := NewPerson(\"小王子\", 25)\n    	fmt.Println(p1.age) // 25\n    	p1.SetAge(30)\n    	fmt.Println(p1.age) // 30\n    }\n    \n\n### 值类型的接收者\n\n当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。\n\n    // SetAge2 设置p的年龄\n    // 使用值接收者\n    func (p Person) SetAge2(newAge int8) {\n    	p.age = newAge\n    }\n    \n    func main() {\n    	p1 := NewPerson(\"小王子\", 25)\n    	p1.Dream()\n    	fmt.Println(p1.age) // 25\n    	p1.SetAge2(30) // (*p1).SetAge2(30)\n    	fmt.Println(p1.age) // 25\n    }\n    \n\n### 什么时候应该使用指针类型接收者\n\n1.  需要修改接收者中的值\n2.  接收者是拷贝代价比较大的大对象\n3.  保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。\n\n任意类型添加方法\n--------\n\n在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的`int`类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。\n\n    //MyInt 将int定义为自定义MyInt类型\n    type MyInt int\n    \n    //SayHello 为MyInt添加一个SayHello的方法\n    func (m MyInt) SayHello() {\n    	fmt.Println(\"Hello, 我是一个int。\")\n    }\n    func main() {\n    	var m1 MyInt\n    	m1.SayHello() //Hello, 我是一个int。\n    	m1 = 100\n    	fmt.Printf(\"%#v  %T\\n\", m1, m1) //100  main.MyInt\n    }\n    \n\n**注意事项：** 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。\n\n结构体的匿名字段\n--------\n\n结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。\n\n    //Person 结构体Person类型\n    type Person struct {\n    	string\n    	int\n    }\n    \n    func main() {\n    	p1 := Person{\n    		\"小王子\",\n    		18,\n    	}\n    	fmt.Printf(\"%#v\\n\", p1)        //main.Person{string:\"北京\", int:18}\n    	fmt.Println(p1.string, p1.int) //北京 18\n    }\n    \n\n匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。\n\n嵌套结构体\n-----\n\n一个结构体中可以嵌套包含另一个结构体或结构体指针。\n\n    //Address 地址结构体\n    type Address struct {\n    	Province string\n    	City     string\n    }\n    \n    //User 用户结构体\n    type User struct {\n    	Name    string\n    	Gender  string\n    	Address Address\n    }\n    \n    func main() {\n    	user1 := User{\n    		Name:   \"小王子\",\n    		Gender: \"男\",\n    		Address: Address{\n    			Province: \"山东\",\n    			City:     \"威海\",\n    		},\n    	}\n    	fmt.Printf(\"user1=%#v\\n\", user1)//user1=main.User{Name:\"小王子\", Gender:\"男\", Address:main.Address{Province:\"山东\", City:\"威海\"}}\n    }\n    \n\n### 嵌套匿名结构体\n\n    //Address 地址结构体\n    type Address struct {\n    	Province string\n    	City     string\n    }\n    \n    //User 用户结构体\n    type User struct {\n    	Name    string\n    	Gender  string\n    	Address //匿名结构体\n    }\n    \n    func main() {\n    	var user2 User\n    	user2.Name = \"小王子\"\n    	user2.Gender = \"男\"\n    	user2.Address.Province = \"山东\"    //通过匿名结构体.字段名访问\n    	user2.City = \"威海\"                //直接访问匿名结构体的字段名\n    	fmt.Printf(\"user2=%#v\\n\", user2) //user2=main.User{Name:\"小王子\", Gender:\"男\", Address:main.Address{Province:\"山东\", City:\"威海\"}}\n    }\n    \n\n当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。\n\n### 嵌套结构体的字段名冲突\n\n嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。\n\n    //Address 地址结构体\n    type Address struct {\n    	Province   string\n    	City       string\n    	CreateTime string\n    }\n    \n    //Email 邮箱结构体\n    type Email struct {\n    	Account    string\n    	CreateTime string\n    }\n    \n    //User 用户结构体\n    type User struct {\n    	Name   string\n    	Gender string\n    	Address\n    	Email\n    }\n    \n    func main() {\n    	var user3 User\n    	user3.Name = \"沙河娜扎\"\n    	user3.Gender = \"男\"\n    	// user3.CreateTime = \"2019\" //ambiguous selector user3.CreateTime\n    	user3.Address.CreateTime = \"2000\" //指定Address结构体中的CreateTime\n    	user3.Email.CreateTime = \"2000\"   //指定Email结构体中的CreateTime\n    }\n    \n\n结构体的“继承”\n--------\n\nGo语言中使用结构体也可以实现其他编程语言中面向对象的继承。\n\n    //Animal 动物\n    type Animal struct {\n    	name string\n    }\n    \n    func (a *Animal) move() {\n    	fmt.Printf(\"%s会动！\\n\", a.name)\n    }\n    \n    //Dog 狗\n    type Dog struct {\n    	Feet    int8\n    	*Animal //通过嵌套匿名结构体实现继承\n    }\n    \n    func (d *Dog) wang() {\n    	fmt.Printf(\"%s会汪汪汪~\\n\", d.name)\n    }\n    \n    func main() {\n    	d1 := &Dog{\n    		Feet: 4,\n    		Animal: &Animal{ //注意嵌套的是结构体指针\n    			name: \"乐乐\",\n    		},\n    	}\n    	d1.wang() //乐乐会汪汪汪~\n    	d1.move() //乐乐会动！\n    }\n    \n\n结构体字段的可见性\n---------\n\n结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。\n\n结构体与JSON序列化\n-----------\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号`\"\"`包裹，使用冒号`:`分隔，然后紧接着值；多个键值之间使用英文`,`分隔。\n\n    //Student 学生\n    type Student struct {\n    	ID     int\n    	Gender string\n    	Name   string\n    }\n    \n    //Class 班级\n    type Class struct {\n    	Title    string\n    	Students []*Student\n    }\n    \n    func main() {\n    	c := &Class{\n    		Title:    \"101\",\n    		Students: make([]*Student, 0, 200),\n    	}\n    	for i := 0; i < 10; i++ {\n    		stu := &Student{\n    			Name:   fmt.Sprintf(\"stu%02d\", i),\n    			Gender: \"男\",\n    			ID:     i,\n    		}\n    		c.Students = append(c.Students, stu)\n    	}\n    	//JSON序列化：结构体-->JSON格式的字符串\n    	data, err := json.Marshal(c)\n    	if err != nil {\n    		fmt.Println(\"json marshal failed\")\n    		return\n    	}\n    	fmt.Printf(\"json:%s\\n\", data)\n    	//JSON反序列化：JSON格式的字符串-->结构体\n    	str := `{\"Title\":\"101\",\"Students\":[{\"ID\":0,\"Gender\":\"男\",\"Name\":\"stu00\"},{\"ID\":1,\"Gender\":\"男\",\"Name\":\"stu01\"},{\"ID\":2,\"Gender\":\"男\",\"Name\":\"stu02\"},{\"ID\":3,\"Gender\":\"男\",\"Name\":\"stu03\"},{\"ID\":4,\"Gender\":\"男\",\"Name\":\"stu04\"},{\"ID\":5,\"Gender\":\"男\",\"Name\":\"stu05\"},{\"ID\":6,\"Gender\":\"男\",\"Name\":\"stu06\"},{\"ID\":7,\"Gender\":\"男\",\"Name\":\"stu07\"},{\"ID\":8,\"Gender\":\"男\",\"Name\":\"stu08\"},{\"ID\":9,\"Gender\":\"男\",\"Name\":\"stu09\"}]}`\n    	c1 := &Class{}\n    	err = json.Unmarshal([]byte(str), c1)\n    	if err != nil {\n    		fmt.Println(\"json unmarshal failed!\")\n    		return\n    	}\n    	fmt.Printf(\"%#v\\n\", c1)\n    }\n    \n\n结构体标签（Tag）\n----------\n\n`Tag`是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 `Tag`在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：\n\n    `key1:\"value1\" key2:\"value2\"`\n    \n\n结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 **注意事项：** 为结构体编写`Tag`时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。\n\n例如我们为`Student`结构体的每个字段定义json序列化时使用的Tag：\n\n    //Student 学生\n    type Student struct {\n    	ID     int    `json:\"id\"` //通过指定tag实现json序列化该字段时的key\n    	Gender string //json序列化是默认使用字段名作为key\n    	name   string //私有不能被json包访问\n    }\n    \n    func main() {\n    	s1 := Student{\n    		ID:     1,\n    		Gender: \"男\",\n    		name:   \"沙河娜扎\",\n    	}\n    	data, err := json.Marshal(s1)\n    	if err != nil {\n    		fmt.Println(\"json marshal failed!\")\n    		return\n    	}\n    	fmt.Printf(\"json str:%s\\n\", data) //json str:{\"id\":1,\"Gender\":\"男\"}\n    }\n    \n\n练习题\n===\n\n1.  使用“面向对象”的思维方式编写一个学生信息管理系统。\n    1.  学生有id、姓名、年龄、分数等信息\n    2.  程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能', 'Go语言基础之结构体', 4, 0, 'q1mi', 'Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。');
INSERT INTO `article` VALUES (2, '在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。\n\nGo语言的包（package）\n===============\n\n包介绍\n---\n\n`包（package）`是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如`fmt`、`os`、`io`等。\n\n定义包\n---\n\n我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放`.go`文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。\n\n    package 包名\n    \n\n注意事项：\n\n*   一个文件夹下面只能有一个包，同样一个包的文件不能在多个文件夹下。\n*   包名可以不和文件夹的名字一样，包名不能包含`-`符号。\n*   包名为main的包为应用程序的入口包，编译时不包含main包的源代码时不会得到可执行文件。\n\n可见性\n---\n\n如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。\n\n举个例子， 我们定义一个包名为`pkg2`的包，代码如下：\n\n    package pkg2\n    \n    import \"fmt\"\n    \n    // 包变量可见性\n    \n    var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用\n    \n    // 首字母大写外部包可见，可在其他包中使用\n    const Mode = 1\n    \n    type person struct { // 首字母小写，外部包不可见，只能在当前包内使用\n    	name string\n    }\n    \n    // 首字母大写，外部包可见，可在其他包中使用\n    func Add(x, y int) int {\n    	return x + y\n    }\n    \n    func age() { // 首字母小写，外部包不可见，只能在当前包内使用\n    	var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用\n    	fmt.Println(Age)\n    }\n    \n\n结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：\n\n    type Student struct {\n    	Name  string //可在包外访问的方法\n    	class string //仅限包内访问的字段\n    }\n    \n    type Payer interface {\n    	init() //仅限包内访问的方法\n    	Pay()  //可在包外访问的方法\n    }\n    \n\n包的导入\n----\n\n要在代码中引用其他包的内容，需要使用`import`关键字导入使用的包。具体语法如下:\n\n    import \"包的路径\"\n    \n\n注意事项：\n\n*   import导入语句通常放在文件开头包声明语句的下面。\n*   导入的包名需要使用双引号包裹起来。\n*   包名是从`$GOPATH/src/`后开始计算的，使用`/`进行路径分隔。\n*   Go语言中禁止循环导入包。\n\n### 单行导入\n\n单行导入的格式如下：\n\n    import \"包1\"\n    import \"包2\"\n    \n\n### 多行导入\n\n多行导入的格式如下：\n\n    import (\n        \"包1\"\n        \"包2\"\n    )\n    \n\n自定义包名\n-----\n\n在导入包名的时候，我们还可以为导入的包设置别名。具体语法格式如下：\n\n    import 别名 \"包的路径\"\n    \n\n单行导入方式定义别名：\n\n    import \"fmt\"\n    import m \"github.com/Q1mi/studygo/pkg_test\"\n    \n    func main() {\n    	fmt.Println(m.Add(100, 200))\n    	fmt.Println(m.Mode)\n    }\n    \n\n多行导入方式定义别名：\n\n    import (\n        \"fmt\"\n        m \"github.com/Q1mi/studygo/pkg_test\"\n     )\n    \n    func main() {\n    	fmt.Println(m.Add(100, 200))\n    	fmt.Println(m.Mode)\n    }\n    \n\n匿名导入包\n-----\n\n如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下：\n\n    import _ \"包的路径\"\n    \n\n匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。\n\ninit()初始化函数\n-----------\n\n### init()函数介绍\n\n在Go语言程序执行时导入包语句会自动触发包内部`init()`函数的调用。需要注意的是： `init()`函数没有参数也没有返回值。 `init()`函数在程序运行时自动被调用执行，不能在代码中主动调用它。\n\n包初始化执行的顺序如下图所示： ![包中的init()执行时机](/images/Go/package/init01.png)\n\n### init()函数执行顺序\n\nGo语言包会从`main`包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。\n\n在运行时，被最后导入的包会最先初始化并调用其`init()`函数， 如下图示： ![包之间的init()执行顺序](/images/Go/package/init02.png)\n\n练习题\n===\n\n1.  编写一个`clac`包实现加减乘除四个功能函数，在`snow`这个包中导入并使用加减乘除四个函数实现数学运算。', 'Go语言基础之包', 1, 0, 'q1mi', '在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。');
INSERT INTO `article` VALUES (3, '本文介绍了Go语言反射的意义和基本使用。\n\n变量的内在机制\n=======\n\nGo语言中的变量是分为两部分的:\n\n*   类型信息：预先定义好的元信息。\n*   值信息：程序运行过程中可动态变化的。\n\n反射介绍\n====\n\n反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。\n\n支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。\n\nGo程序在运行期使用reflect包访问程序的反射信息。\n\n在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。\n\nreflect包\n========\n\n在Go语言的反射机制中，任何接口值都由是`一个具体类型`和`具体类型的值`两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由`reflect.Type`和`reflect.Value`两部分组成，并且reflect包提供了`reflect.TypeOf`和`reflect.ValueOf`两个函数来获取任意对象的Value和Type。\n\nTypeOf\n------\n\n在Go语言中，使用`reflect.TypeOf()`函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。\n\n    package main\n    \n    import (\n    	\"fmt\"\n    	\"reflect\"\n    )\n    \n    func reflectType(x interface{}) {\n    	v := reflect.TypeOf(x)\n    	fmt.Printf(\"type:%v\\n\", v)\n    }\n    func main() {\n    	var a float32 = 3.14\n    	reflectType(a) // type:float32\n    	var b int64 = 100\n    	reflectType(b) // type:int64\n    }\n    \n\n### type name和type kind\n\n在反射中关于类型还划分为两种：`类型（Type）`和`种类（Kind）`。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而`种类（Kind）`就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到`种类（Kind）`。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。\n\n    package main\n    \n    import (\n    	\"fmt\"\n    	\"reflect\"\n    )\n    \n    type myInt int64\n    \n    func reflectType(x interface{}) {\n    	t := reflect.TypeOf(x)\n    	fmt.Printf(\"type:%v kind:%v\\n\", t.Name(), t.Kind())\n    }\n    \n    func main() {\n    	var a *float32 // 指针\n    	var b myInt    // 自定义类型\n    	var c rune     // 类型别名\n    	reflectType(a) // type: kind:ptr\n    	reflectType(b) // type:myInt kind:int64\n    	reflectType(c) // type:int32 kind:int32\n    \n    	type person struct {\n    		name string\n    		age  int\n    	}\n    	type book struct{ title string }\n    	var d = person{\n    		name: \"沙河小王子\",\n    		age:  18,\n    	}\n    	var e = book{title: \"《跟小王子学Go语言》\"}\n    	reflectType(d) // type:person kind:struct\n    	reflectType(e) // type:book kind:struct\n    }\n    \n\nGo语言的反射中像数组、切片、Map、指针等类型的变量，它们的`.Name()`都是返回`空`。\n\n在`reflect`包中定义的Kind类型如下：\n\n    type Kind uint\n    const (\n        Invalid Kind = iota  // 非法类型\n        Bool                 // 布尔型\n        Int                  // 有符号整型\n        Int8                 // 有符号8位整型\n        Int16                // 有符号16位整型\n        Int32                // 有符号32位整型\n        Int64                // 有符号64位整型\n        Uint                 // 无符号整型\n        Uint8                // 无符号8位整型\n        Uint16               // 无符号16位整型\n        Uint32               // 无符号32位整型\n        Uint64               // 无符号64位整型\n        Uintptr              // 指针\n        Float32              // 单精度浮点数\n        Float64              // 双精度浮点数\n        Complex64            // 64位复数类型\n        Complex128           // 128位复数类型\n        Array                // 数组\n        Chan                 // 通道\n        Func                 // 函数\n        Interface            // 接口\n        Map                  // 映射\n        Ptr                  // 指针\n        Slice                // 切片\n        String               // 字符串\n        Struct               // 结构体\n        UnsafePointer        // 底层指针\n    )\n    \n\nValueOf\n-------\n\n`reflect.ValueOf()`返回的是`reflect.Value`类型，其中包含了原始值的值信息。`reflect.Value`与原始值之间可以互相转换。\n\n`reflect.Value`类型提供的获取原始值的方法如下：\n\n方法\n\n说明\n\nInterface() interface {}\n\n将值以 interface{} 类型返回，可以通过类型断言转换为指定类型\n\nInt() int64\n\n将值以 int 类型返回，所有有符号整型均可以此方式返回\n\nUint() uint64\n\n将值以 uint 类型返回，所有无符号整型均可以此方式返回\n\nFloat() float64\n\n将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回\n\nBool() bool\n\n将值以 bool 类型返回\n\nBytes() \\[\\]bytes\n\n将值以字节数组 \\[\\]bytes 类型返回\n\nString() string\n\n将值以字符串类型返回\n\n### 通过反射获取值\n\n    func reflectValue(x interface{}) {\n    	v := reflect.ValueOf(x)\n    	k := v.Kind()\n    	switch k {\n    	case reflect.Int64:\n    		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换\n    		fmt.Printf(\"type is int64, value is %d\\n\", int64(v.Int()))\n    	case reflect.Float32:\n    		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换\n    		fmt.Printf(\"type is float32, value is %f\\n\", float32(v.Float()))\n    	case reflect.Float64:\n    		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换\n    		fmt.Printf(\"type is float64, value is %f\\n\", float64(v.Float()))\n    	}\n    }\n    func main() {\n    	var a float32 = 3.14\n    	var b int64 = 100\n    	reflectValue(a) // type is float32, value is 3.140000\n    	reflectValue(b) // type is int64, value is 100\n    	// 将int类型的原始值转换为reflect.Value类型\n    	c := reflect.ValueOf(10)\n    	fmt.Printf(\"type c :%T\\n\", c) // type c :reflect.Value\n    }\n    \n\n### 通过反射设置变量的值\n\n想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的`Elem()`方法来获取指针对应的值。\n\n    package main\n    \n    import (\n    	\"fmt\"\n    	\"reflect\"\n    )\n    \n    func reflectSetValue1(x interface{}) {\n    	v := reflect.ValueOf(x)\n    	if v.Kind() == reflect.Int64 {\n    		v.SetInt(200) //修改的是副本，reflect包会引发panic\n    	}\n    }\n    func reflectSetValue2(x interface{}) {\n    	v := reflect.ValueOf(x)\n    	// 反射中使用 Elem()方法获取指针对应的值\n    	if v.Elem().Kind() == reflect.Int64 {\n    		v.Elem().SetInt(200)\n    	}\n    }\n    func main() {\n    	var a int64 = 100\n    	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value\n    	reflectSetValue2(&a)\n    	fmt.Println(a)\n    }\n    \n\n### isNil()和isValid()\n\n#### isNil()\n\n    func (v Value) IsNil() bool\n    \n\n`IsNil()`报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。\n\n#### isValid()\n\n    func (v Value) IsValid() bool\n    \n\n`IsValid()`返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。\n\n#### 举个例子\n\n`IsNil()`常被用于判断指针是否为空；`IsValid()`常被用于判定返回值是否有效。\n\n    func main() {\n    	// *int类型空指针\n    	var a *int\n    	fmt.Println(\"var a *int IsNil:\", reflect.ValueOf(a).IsNil())\n    	// nil值\n    	fmt.Println(\"nil IsValid:\", reflect.ValueOf(nil).IsValid())\n    	// 实例化一个匿名结构体\n    	b := struct{}{}\n    	// 尝试从结构体中查找\"abc\"字段\n    	fmt.Println(\"不存在的结构体成员:\", reflect.ValueOf(b).FieldByName(\"abc\").IsValid())\n    	// 尝试从结构体中查找\"abc\"方法\n    	fmt.Println(\"不存在的结构体方法:\", reflect.ValueOf(b).MethodByName(\"abc\").IsValid())\n    	// map\n    	c := map[string]int{}\n    	// 尝试从map中查找一个不存在的键\n    	fmt.Println(\"map中不存在的键：\", reflect.ValueOf(c).MapIndex(reflect.ValueOf(\"娜扎\")).IsValid())\n    }\n    \n\n结构体反射\n=====\n\n与结构体相关的方法\n---------\n\n任意值通过`reflect.TypeOf()`获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（`reflect.Type`）的`NumField()`和`Field()`方法获得结构体成员的详细信息。\n\n`reflect.Type`中与获取结构体成员相关的的方法如下表所示。\n\n方法\n\n说明\n\nField(i int) StructField\n\n根据索引，返回索引对应的结构体字段的信息。\n\nNumField() int\n\n返回结构体成员字段数量。\n\nFieldByName(name string) (StructField, bool)\n\n根据给定字符串返回字符串对应的结构体字段的信息。\n\nFieldByIndex(index \\[\\]int) StructField\n\n多层成员访问时，根据 \\[\\]int 提供的每个结构体的字段索引，返回字段的信息。\n\nFieldByNameFunc(match func(string) bool) (StructField,bool)\n\n根据传入的匹配函数匹配需要的字段。\n\nNumMethod() int\n\n返回该类型的方法集中方法的数目\n\nMethod(int) Method\n\n返回该类型方法集中的第i个方法\n\nMethodByName(string)(Method, bool)\n\n根据方法名返回该类型方法集中的方法\n\nStructField类型\n-------------\n\n`StructField`类型用来描述结构体中的一个字段的信息。\n\n`StructField`的定义如下：\n\n    type StructField struct {\n        // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为\"\"。\n        // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers\n        Name    string\n        PkgPath string\n        Type      Type      // 字段的类型\n        Tag       StructTag // 字段的标签\n        Offset    uintptr   // 字段在结构体中的字节偏移量\n        Index     []int     // 用于Type.FieldByIndex时的索引切片\n        Anonymous bool      // 是否匿名字段\n    }\n    \n\n结构体反射示例\n-------\n\n当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。\n\n    type student struct {\n    	Name  string `json:\"name\"`\n    	Score int    `json:\"score\"`\n    }\n    \n    func main() {\n    	stu1 := student{\n    		Name:  \"小王子\",\n    		Score: 90,\n    	}\n    \n    	t := reflect.TypeOf(stu1)\n    	fmt.Println(t.Name(), t.Kind()) // student struct\n    	// 通过for循环遍历结构体的所有字段信息\n    	for i := 0; i < t.NumField(); i++ {\n    		field := t.Field(i)\n    		fmt.Printf(\"name:%s index:%d type:%v json tag:%v\\n\", field.Name, field.Index, field.Type, field.Tag.Get(\"json\"))\n    	}\n    \n    	// 通过字段名获取指定结构体字段信息\n    	if scoreField, ok := t.FieldByName(\"Score\"); ok {\n    		fmt.Printf(\"name:%s index:%d type:%v json tag:%v\\n\", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(\"json\"))\n    	}\n    }\n    \n\n接下来编写一个函数`printMethod(s interface{})`来遍历打印s包含的方法。\n\n    // 给student添加两个方法 Study和Sleep(注意首字母大写)\n    func (s student) Study() string {\n    	msg := \"好好学习，天天向上。\"\n    	fmt.Println(msg)\n    	return msg\n    }\n    \n    func (s student) Sleep() string {\n    	msg := \"好好睡觉，快快长大。\"\n    	fmt.Println(msg)\n    	return msg\n    }\n    \n    func printMethod(x interface{}) {\n    	t := reflect.TypeOf(x)\n    	v := reflect.ValueOf(x)\n    \n    	fmt.Println(t.NumMethod())\n    	for i := 0; i < v.NumMethod(); i++ {\n    		methodType := v.Method(i).Type()\n    		fmt.Printf(\"method name:%s\\n\", t.Method(i).Name)\n    		fmt.Printf(\"method:%s\\n\", methodType)\n    		// 通过反射调用方法传递的参数必须是 []reflect.Value 类型\n    		var args = []reflect.Value{}\n    		v.Method(i).Call(args)\n    	}\n    }\n    \n\n反射是把双刃剑\n=======\n\n反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。\n\n1.  基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。\n2.  大量使用反射的代码通常难以理解。\n3.  反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。\n\n练习题\n===\n\n1.  编写代码利用反射实现一个ini文件的解析器程序。', 'Go语言基础之反射', 2, 0, 'q1mi', '本文介绍了Go语言反射的意义和基本使用。');
INSERT INTO `article` VALUES (4, '现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。\n\n互联网协议介绍\n=======\n\n互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。\n\n互联网分层模型\n-------\n\n互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。 ![osi七层模型](/images/Go/socket/osi.png) 如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。\n\n接下来我们一层一层的自底向上介绍一下每一层。\n\n### 物理层\n\n我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、无线电波等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。\n\n### 数据链路层\n\n单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：多少个电信号算一组？每个信号位有何意义？这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。\n\n以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。\n\n那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n\n我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。\n\n### 网络层\n\n按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。\n\n因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。\n\n“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。\n\n规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。\n\n根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。\n\n### 传输层\n\n有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n\n“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。\n\n我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。\n\nUDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\n\n### 应用层\n\n应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。\n\n如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。\n\n![HTTP数据传输图解](/images/Go/socket/httptcpip.png)\n\nsocket编程\n========\n\nSocket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。\n\nsocket图解\n--------\n\n`Socket`是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，`Socket`其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在`Socket`后面，对用户来说只需要调用Socket规定的相关函数，让`Socket`去组织符合指定的协议数据然后进行通信。\n\n![socket图解](/images/Go/socket/socket.png)\n\nGo语言实现TCP通信\n-----------\n\n### TCP协议\n\nTCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。\n\n### TCP服务端\n\n一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。\n\nTCP服务端程序的处理流程：\n\n1.  监听端口\n2.  接收客户端请求建立链接\n3.  创建goroutine处理链接。\n\n我们使用Go语言的net包实现的TCP服务端代码如下：\n\n    // tcp/server/main.go\n    \n    // TCP server端\n    \n    // 处理函数\n    func process(conn net.Conn) {\n    	defer conn.Close() // 关闭连接\n    	for {\n    		reader := bufio.NewReader(conn)\n    		var buf [128]byte\n    		n, err := reader.Read(buf[:]) // 读取数据\n    		if err != nil {\n    			fmt.Println(\"read from client failed, err:\", err)\n    			break\n    		}\n    		recvStr := string(buf[:n])\n    		fmt.Println(\"收到client端发来的数据：\", recvStr)\n    		conn.Write([]byte(recvStr)) // 发送数据\n    	}\n    }\n    \n    func main() {\n    	listen, err := net.Listen(\"tcp\", \"127.0.0.1:20000\")\n    	if err != nil {\n    		fmt.Println(\"listen failed, err:\", err)\n    		return\n    	}\n    	for {\n    		conn, err := listen.Accept() // 建立连接\n    		if err != nil {\n    			fmt.Println(\"accept failed, err:\", err)\n    			continue\n    		}\n    		go process(conn) // 启动一个goroutine处理连接\n    	}\n    }\n    \n\n将上面的代码保存之后编译成`server`或`server.exe`可执行文件。\n\n### TCP客户端\n\n一个TCP客户端进行TCP通信的流程如下：\n\n1.  建立与服务端的链接\n2.  进行数据收发\n3.  关闭链接\n\n使用Go语言的net包实现的TCP客户端代码如下：\n\n    // tcp/client/main.go\n    \n    // 客户端\n    func main() {\n    	conn, err := net.Dial(\"tcp\", \"127.0.0.1:20000\")\n    	if err != nil {\n    		fmt.Println(\"err :\", err)\n    		return\n    	}\n    	defer conn.Close() // 关闭连接\n    	inputReader := bufio.NewReader(os.Stdin)\n    	for {\n    		input, _ := inputReader.ReadString(\'\\n\') // 读取用户输入\n    		inputInfo := strings.Trim(input, \"\\r\\n\")\n    		if strings.ToUpper(inputInfo) == \"Q\" { // 如果输入q就退出\n    			return\n    		}\n    		_, err = conn.Write([]byte(inputInfo)) // 发送数据\n    		if err != nil {\n    			return\n    		}\n    		buf := [512]byte{}\n    		n, err := conn.Read(buf[:])\n    		if err != nil {\n    			fmt.Println(\"recv failed, err:\", err)\n    			return\n    		}\n    		fmt.Println(string(buf[:n]))\n    	}\n    }\n    \n\n将上面的代码编译成`client`或`client.exe`可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。\n\nTCP黏包\n-----\n\n### 黏包示例\n\n服务端代码如下：\n\n    // socket_stick/server/main.go\n    \n    func process(conn net.Conn) {\n    	defer conn.Close()\n    	reader := bufio.NewReader(conn)\n    	var buf [1024]byte\n    	for {\n    		n, err := reader.Read(buf[:])\n    		if err == io.EOF {\n    			break\n    		}\n    		if err != nil {\n    			fmt.Println(\"read from client failed, err:\", err)\n    			break\n    		}\n    		recvStr := string(buf[:n])\n    		fmt.Println(\"收到client发来的数据：\", recvStr)\n    	}\n    }\n    \n    func main() {\n    \n    	listen, err := net.Listen(\"tcp\", \"127.0.0.1:30000\")\n    	if err != nil {\n    		fmt.Println(\"listen failed, err:\", err)\n    		return\n    	}\n    	defer listen.Close()\n    	for {\n    		conn, err := listen.Accept()\n    		if err != nil {\n    			fmt.Println(\"accept failed, err:\", err)\n    			continue\n    		}\n    		go process(conn)\n    	}\n    }\n    \n\n客户端代码如下：\n\n    // socket_stick/client/main.go\n    \n    func main() {\n    	conn, err := net.Dial(\"tcp\", \"127.0.0.1:30000\")\n    	if err != nil {\n    		fmt.Println(\"dial failed, err\", err)\n    		return\n    	}\n    	defer conn.Close()\n    	for i := 0; i < 20; i++ {\n    		msg := `Hello, Hello. How are you?`\n    		conn.Write([]byte(msg))\n    	}\n    }\n    \n\n将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：\n```\n收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?\n收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?\n收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?\n收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?\n收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?\n    \n```\n客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。\n\n### 为什么会出现粘包\n\n主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。\n\n“粘包”可发生在发送端也可发生在接收端：\n\n1.  由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。\n2.  接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。\n\n### 解决办法\n\n出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。\n\n封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。\n\n我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。\n\n    // socket_stick/proto/proto.go\n    package proto\n    \n    import (\n    	\"bufio\"\n    	\"bytes\"\n    	\"encoding/binary\"\n    )\n    \n    // Encode 将消息编码\n    func Encode(message string) ([]byte, error) {\n    	// 读取消息的长度，转换成int32类型（占4个字节）\n    	var length = int32(len(message))\n    	var pkg = new(bytes.Buffer)\n    	// 写入消息头\n    	err := binary.Write(pkg, binary.LittleEndian, length)\n    	if err != nil {\n    		return nil, err\n    	}\n    	// 写入消息实体\n    	err = binary.Write(pkg, binary.LittleEndian, []byte(message))\n    	if err != nil {\n    		return nil, err\n    	}\n    	return pkg.Bytes(), nil\n    }\n    \n    // Decode 解码消息\n    func Decode(reader *bufio.Reader) (string, error) {\n    	// 读取消息的长度\n    	lengthByte, _ := reader.Peek(4) // 读取前4个字节的数据\n    	lengthBuff := bytes.NewBuffer(lengthByte)\n    	var length int32\n    	err := binary.Read(lengthBuff, binary.LittleEndian, &length)\n    	if err != nil {\n    		return \"\", err\n    	}\n    	// Buffered返回缓冲中现有的可读取的字节数。\n    	if int32(reader.Buffered()) < length+4 {\n    		return \"\", err\n    	}\n    \n    	// 读取真正的消息数据\n    	pack := make([]byte, int(4+length))\n    	_, err = reader.Read(pack)\n    	if err != nil {\n    		return \"\", err\n    	}\n    	return string(pack[4:]), nil\n    }\n    \n\n接下来在服务端和客户端分别使用上面定义的`proto`包的`Decode`和`Encode`函数处理数据。\n\n服务端代码如下：\n\n    // socket_stick/server2/main.go\n    \n    func process(conn net.Conn) {\n    	defer conn.Close()\n    	reader := bufio.NewReader(conn)\n    	for {\n    		msg, err := proto.Decode(reader)\n    		if err == io.EOF {\n    			return\n    		}\n    		if err != nil {\n    			fmt.Println(\"decode msg failed, err:\", err)\n    			return\n    		}\n    		fmt.Println(\"收到client发来的数据：\", msg)\n    	}\n    }\n    \n    func main() {\n    \n    	listen, err := net.Listen(\"tcp\", \"127.0.0.1:30000\")\n    	if err != nil {\n    		fmt.Println(\"listen failed, err:\", err)\n    		return\n    	}\n    	defer listen.Close()\n    	for {\n    		conn, err := listen.Accept()\n    		if err != nil {\n    			fmt.Println(\"accept failed, err:\", err)\n    			continue\n    		}\n    		go process(conn)\n    	}\n    }\n    \n\n客户端代码如下：\n\n    // socket_stick/client2/main.go\n    \n    func main() {\n    	conn, err := net.Dial(\"tcp\", \"127.0.0.1:30000\")\n    	if err != nil {\n    		fmt.Println(\"dial failed, err\", err)\n    		return\n    	}\n    	defer conn.Close()\n    	for i := 0; i < 20; i++ {\n    		msg := `Hello, Hello. How are you?`\n    		data, err := proto.Encode(msg)\n    		if err != nil {\n    			fmt.Println(\"encode msg failed, err:\", err)\n    			return\n    		}\n    		conn.Write(data)\n    	}\n    }\n    \n\nGo语言实现UDP通信\n-----------\n\n### UDP协议\n\nUDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种**无连接**的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。\n\n### UDP服务端\n\n使用Go语言的`net`包实现的UDP服务端代码如下：\n\n    // UDP/server/main.go\n    \n    // UDP server端\n    func main() {\n    	listen, err := net.ListenUDP(\"udp\", &net.UDPAddr{\n    		IP:   net.IPv4(0, 0, 0, 0),\n    		Port: 30000,\n    	})\n    	if err != nil {\n    		fmt.Println(\"listen failed, err:\", err)\n    		return\n    	}\n    	defer listen.Close()\n    	for {\n    		var data [1024]byte\n    		n, addr, err := listen.ReadFromUDP(data[:]) // 接收数据\n    		if err != nil {\n    			fmt.Println(\"read udp failed, err:\", err)\n    			continue\n    		}\n    		fmt.Printf(\"data:%v addr:%v count:%v\\n\", string(data[:n]), addr, n)\n    		_, err = listen.WriteToUDP(data[:n], addr) // 发送数据\n    		if err != nil {\n    			fmt.Println(\"write to udp failed, err:\", err)\n    			continue\n    		}\n    	}\n    }\n    \n\n### UDP客户端\n\n使用Go语言的`net`包实现的UDP客户端代码如下：\n\n    // UDP 客户端\n    func main() {\n    	socket, err := net.DialUDP(\"udp\", nil, &net.UDPAddr{\n    		IP:   net.IPv4(0, 0, 0, 0),\n    		Port: 30000,\n    	})\n    	if err != nil {\n    		fmt.Println(\"连接服务端失败，err:\", err)\n    		return\n    	}\n    	defer socket.Close()\n    	sendData := []byte(\"Hello server\")\n    	_, err = socket.Write(sendData) // 发送数据\n    	if err != nil {\n    		fmt.Println(\"发送数据失败，err:\", err)\n    		return\n    	}\n    	data := make([]byte, 4096)\n    	n, remoteAddr, err := socket.ReadFromUDP(data) // 接收数据\n    	if err != nil {\n    		fmt.Println(\"接收数据失败，err:\", err)\n    		return\n    	}\n    	fmt.Printf(\"recv:%v addr:%v count:%v\\n\", string(data[:n]), remoteAddr, n)\n    }', 'Go语言基础之网络编程', 3, 0, 'q1mi', '现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。');
INSERT INTO `article` VALUES (20, '# #一级标题\n## ##二级标题\n### ###三级标题\n\n***\n\n我是普通的文本。    \n我也是普通的文本。  \n*斜体*  \n**加粗**  \n***加粗的斜体***\n\n***\n\n`is am are`  \n\n***\n\n代码块：\n\n```\nfmt.Println(\"hi\")\n```\n\n***\n图片：\n![UTOOLS1573629119977.png](http://yanxuan.nosdn.127.net/c5d84f45c81c6309bf8ac37f9aa7b9ce.png)    \n\n***\n\n恐怖如斯！！！', 'markdown语法示例', 5, 0, 'sam', 'markdown语法示例。。。');
INSERT INTO `article` VALUES (21, 'boy next door  \ngirl next door', 'do you like 玩游戏', 4, 0, 'sam', '谷歌');
INSERT INTO `article` VALUES (25, '# hello\n## 你好\n```\nfmt.Println(\"hi\")\n```\n|name|age|\n|-|-|\n|tom|12|', 'hello world ', 10, 0, 'tim', '我是摘要');
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论作者',
  `article_id` bigint(20) unsigned NOT NULL COMMENT '对应文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '表ID',
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `gender` varchar(4) COLLATE utf8mb4_general_ci NOT NULL DEFAULT '0' COMMENT '性别',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, 123, 'tom', '111111', 'm');
INSERT INTO `user` VALUES (2, 124, 'sam', '111111', 'w');
INSERT INTO `user` VALUES (3, 12, 'alex', '111111', '0');
INSERT INTO `user` VALUES (4, 78, 'tim', '111111', '0');
INSERT INTO `user` VALUES (14, 1572429807192382000, 'uuu', '111111', '0');
INSERT INTO `user` VALUES (16, 1572653314224344000, 'amy', '111111', '0');
INSERT INTO `user` VALUES (18, 1572925907905362000, 'sf', '1', '0');
INSERT INTO `user` VALUES (19, 1573033200243125000, 'bbb', '1', '0');
INSERT INTO `user` VALUES (20, 1573702749106189000, 'bbbb', '111', '0');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
